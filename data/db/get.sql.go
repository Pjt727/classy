// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: get.sql

package db

import (
	"context"
)

const getMostRecentTermCollection = `-- name: GetMostRecentTermCollection :many
SELECT  
FROM term_collections t
JOIN previous_full_section_collections p 
                    ON t.school_id    = p.school_id
                    AND t.term_year   = p.term_year
                    AND t.term_season = p.term_season
                    AND t.season_kind = p.season_kind
ORDER BY p.time_collection DESC
LIMIT 1
`

type GetMostRecentTermCollectionRow struct {
	TermCollection TermCollection `json:"term_collection"`
}

func (q *Queries) GetMostRecentTermCollection(ctx context.Context) ([]GetMostRecentTermCollectionRow, error) {
	rows, err := q.db.Query(ctx, getMostRecentTermCollection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostRecentTermCollectionRow
	for rows.Next() {
		var i GetMostRecentTermCollectionRow
		if err := rows.Scan(
			&i.TermCollection.ID,
			&i.TermCollection.SchoolID,
			&i.TermCollection.Year,
			&i.TermCollection.Season,
			&i.TermCollection.Name,
			&i.TermCollection.StillCollecting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchool = `-- name: GetSchool :one
SELECT schools.id, schools.name
FROM schools
WHERE id = $1
LIMIT 1
`

type GetSchoolRow struct {
	School School `json:"school"`
}

func (q *Queries) GetSchool(ctx context.Context, schoolID string) (GetSchoolRow, error) {
	row := q.db.QueryRow(ctx, getSchool, schoolID)
	var i GetSchoolRow
	err := row.Scan(&i.School.ID, &i.School.Name)
	return i, err
}

const getSchoolsClassesForTermOrderedBySection = `-- name: GetSchoolsClassesForTermOrderedBySection :many
SELECT sections.sequence, sections.term_collection_id, sections.course_id, sections.school_id, sections.max_enrollment, sections.instruction_method, sections.campus, sections.enrollment, sections.primary_faculty_id, courses.id, courses.school_id, courses.subject_code, courses.number, courses.subject_description, courses.title, courses.description, courses.credit_hours, section_meetings.meeting_times
FROM section_meetings
JOIN sections ON sections."sequence" = section_meetings."sequence"
              AND sections.course_id = section_meetings.course_id
              AND sections.school_id = section_meetings.school_id
              AND sections.term_collection_id = section_meetings.term_collection_id
JOIN courses ON sections.course_id = courses.id
             AND sections.school_id = courses.school_id
WHERE sections.school_id = $1
      AND sections.term_collection_id = $2
`

type GetSchoolsClassesForTermOrderedBySectionParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
}

type GetSchoolsClassesForTermOrderedBySectionRow struct {
	Section      Section       `json:"section"`
	Course       Course        `json:"course"`
	MeetingTimes []MeetingTime `json:"meeting_times"`
}

// SELECT sqlc.embed(sections), sqlc.embed(courses), sqlc.embed(meeting_times)
// FROM sections
// JOIN courses ON sections.course_id             = courses.id
//
//	AND sections.school_id            = courses.school_id
//
// JOIN meeting_times ON sections.id              = meeting_times.section_id
//
//	AND sections.school_id            = meeting_times.school_id
//	AND sections.term_collection_id   = meeting_times.term_collection_id
//
// WHERE sections.school_id = @school_id
//
//	AND sections.term_collection_id = @term_collection_id
//
// GROUP BY sections.id
// ;
func (q *Queries) GetSchoolsClassesForTermOrderedBySection(ctx context.Context, arg GetSchoolsClassesForTermOrderedBySectionParams) ([]GetSchoolsClassesForTermOrderedBySectionRow, error) {
	rows, err := q.db.Query(ctx, getSchoolsClassesForTermOrderedBySection, arg.SchoolID, arg.TermCollectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchoolsClassesForTermOrderedBySectionRow
	for rows.Next() {
		var i GetSchoolsClassesForTermOrderedBySectionRow
		if err := rows.Scan(
			&i.Section.Sequence,
			&i.Section.TermCollectionID,
			&i.Section.CourseID,
			&i.Section.SchoolID,
			&i.Section.MaxEnrollment,
			&i.Section.InstructionMethod,
			&i.Section.Campus,
			&i.Section.Enrollment,
			&i.Section.PrimaryFacultyID,
			&i.Course.ID,
			&i.Course.SchoolID,
			&i.Course.SubjectCode,
			&i.Course.Number,
			&i.Course.SubjectDescription,
			&i.Course.Title,
			&i.Course.Description,
			&i.Course.CreditHours,
			&i.MeetingTimes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermCollection = `-- name: GetTermCollection :one
SELECT term_collections.id, term_collections.school_id, term_collections.year, term_collections.season, term_collections.name, term_collections.still_collecting
FROM term_collections
WHERE school_id = $1
      AND id = $2
LIMIT 1
`

type GetTermCollectionParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
}

type GetTermCollectionRow struct {
	TermCollection TermCollection `json:"term_collection"`
}

func (q *Queries) GetTermCollection(ctx context.Context, arg GetTermCollectionParams) (GetTermCollectionRow, error) {
	row := q.db.QueryRow(ctx, getTermCollection, arg.SchoolID, arg.TermCollectionID)
	var i GetTermCollectionRow
	err := row.Scan(
		&i.TermCollection.ID,
		&i.TermCollection.SchoolID,
		&i.TermCollection.Year,
		&i.TermCollection.Season,
		&i.TermCollection.Name,
		&i.TermCollection.StillCollecting,
	)
	return i, err
}

const getTermCollectionsForSchool = `-- name: GetTermCollectionsForSchool :many
SELECT term_collections.id, term_collections.school_id, term_collections.year, term_collections.season, term_collections.name, term_collections.still_collecting 
FROM term_collections 
WHERE school_id = $1
      AND (year = $2 OR $2 IS NULL )
      AND (season = $3 OR $3 IS NULL)
`

type GetTermCollectionsForSchoolParams struct {
	SchoolID string     `json:"school_id"`
	Year     int32      `json:"year"`
	Season   SeasonEnum `json:"season"`
}

type GetTermCollectionsForSchoolRow struct {
	TermCollection TermCollection `json:"term_collection"`
}

func (q *Queries) GetTermCollectionsForSchool(ctx context.Context, arg GetTermCollectionsForSchoolParams) ([]GetTermCollectionsForSchoolRow, error) {
	rows, err := q.db.Query(ctx, getTermCollectionsForSchool, arg.SchoolID, arg.Year, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTermCollectionsForSchoolRow
	for rows.Next() {
		var i GetTermCollectionsForSchoolRow
		if err := rows.Scan(
			&i.TermCollection.ID,
			&i.TermCollection.SchoolID,
			&i.TermCollection.Year,
			&i.TermCollection.Season,
			&i.TermCollection.Name,
			&i.TermCollection.StillCollecting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
