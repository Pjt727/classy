// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const courseExists = `-- name: CourseExists :one
SELECT CASE 
        WHEN EXISTS (
            SELECT 1
            FROM courses
            WHERE school_id = $1
            AND subject_code = $2
            AND number = $3
        ) THEN true
    ELSE false
END
`

type CourseExistsParams struct {
	SchoolID     string `json:"school_id"`
	SubjectCode  string `json:"subject_code"`
	CourseNumber string `json:"course_number"`
}

func (q *Queries) CourseExists(ctx context.Context, arg CourseExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, courseExists, arg.SchoolID, arg.SubjectCode, arg.CourseNumber)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getCourseWithHueristics = `-- name: GetCourseWithHueristics :one
SELECT c.school_id, c.subject_code, c.number, c.subject_description, c.title, c.description, c.credit_hours, c.prerequisites, c.corequisites, c.other, ch.previous_terms, ch.previous_professors
FROM courses c
INNER JOIN course_heuristic ch ON ch.number = c.number
            AND ch.subject_code = c.subject_code
            AND ch.school_id = c.school_id
WHERE c.school_id = $1
      AND c.subject_code = $2
      AND c.number = $3
`

type GetCourseWithHueristicsParams struct {
	SchoolID     string `json:"school_id"`
	SubjectCode  string `json:"subject_code"`
	CourseNumber string `json:"course_number"`
}

type GetCourseWithHueristicsRow struct {
	SchoolID           string             `json:"school_id"`
	SubjectCode        string             `json:"subject_code"`
	Number             string             `json:"number"`
	SubjectDescription pgtype.Text        `json:"subject_description"`
	Title              pgtype.Text        `json:"title"`
	Description        pgtype.Text        `json:"description"`
	CreditHours        float32            `json:"credit_hours"`
	Prerequisites      pgtype.Text        `json:"prerequisites"`
	Corequisites       pgtype.Text        `json:"corequisites"`
	Other              []byte             `json:"other"`
	PreviousTerms      []PartialTerm      `json:"previous_terms"`
	PreviousProfessors []PartialProfessor `json:"previous_professors"`
}

func (q *Queries) GetCourseWithHueristics(ctx context.Context, arg GetCourseWithHueristicsParams) (GetCourseWithHueristicsRow, error) {
	row := q.db.QueryRow(ctx, getCourseWithHueristics, arg.SchoolID, arg.SubjectCode, arg.CourseNumber)
	var i GetCourseWithHueristicsRow
	err := row.Scan(
		&i.SchoolID,
		&i.SubjectCode,
		&i.Number,
		&i.SubjectDescription,
		&i.Title,
		&i.Description,
		&i.CreditHours,
		&i.Prerequisites,
		&i.Corequisites,
		&i.Other,
		&i.PreviousTerms,
		&i.PreviousProfessors,
	)
	return i, err
}

const getCoursesForSchool = `-- name: GetCoursesForSchool :many
SELECT courses.school_id, courses.subject_code, courses.number, courses.subject_description, courses.title, courses.description, courses.credit_hours, courses.prerequisites, courses.corequisites, courses.other
FROM courses
WHERE school_id = $1
LIMIT $3
OFFSET $2
`

type GetCoursesForSchoolParams struct {
	SchoolID    string `json:"school_id"`
	Offsetvalue int32  `json:"offsetvalue"`
	Limitvalue  int32  `json:"limitvalue"`
}

func (q *Queries) GetCoursesForSchool(ctx context.Context, arg GetCoursesForSchoolParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, getCoursesForSchool, arg.SchoolID, arg.Offsetvalue, arg.Limitvalue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.SchoolID,
			&i.SubjectCode,
			&i.Number,
			&i.SubjectDescription,
			&i.Title,
			&i.Description,
			&i.CreditHours,
			&i.Prerequisites,
			&i.Corequisites,
			&i.Other,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesForSchoolAndSubject = `-- name: GetCoursesForSchoolAndSubject :many
SELECT courses.school_id, courses.subject_code, courses.number, courses.subject_description, courses.title, courses.description, courses.credit_hours, courses.prerequisites, courses.corequisites, courses.other
FROM courses
WHERE school_id = $1
      AND subject_code = $2
LIMIT $4
OFFSET $3
`

type GetCoursesForSchoolAndSubjectParams struct {
	SchoolID    string `json:"school_id"`
	SubjectCode string `json:"subject_code"`
	Offsetvalue int32  `json:"offsetvalue"`
	Limitvalue  int32  `json:"limitvalue"`
}

func (q *Queries) GetCoursesForSchoolAndSubject(ctx context.Context, arg GetCoursesForSchoolAndSubjectParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, getCoursesForSchoolAndSubject,
		arg.SchoolID,
		arg.SubjectCode,
		arg.Offsetvalue,
		arg.Limitvalue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.SchoolID,
			&i.SubjectCode,
			&i.Number,
			&i.SubjectDescription,
			&i.Title,
			&i.Description,
			&i.CreditHours,
			&i.Prerequisites,
			&i.Corequisites,
			&i.Other,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchools = `-- name: GetSchools :many
SELECT schools.id, schools.name
FROM schools
LIMIT $2
OFFSET $1
`

type GetSchoolsParams struct {
	Offsetvalue int32 `json:"offsetvalue"`
	Limitvalue  int32 `json:"limitvalue"`
}

func (q *Queries) GetSchools(ctx context.Context, arg GetSchoolsParams) ([]School, error) {
	rows, err := q.db.Query(ctx, getSchools, arg.Offsetvalue, arg.Limitvalue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []School
	for rows.Next() {
		var i School
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchoolsClassesForTermOrderedBySection = `-- name: GetSchoolsClassesForTermOrderedBySection :many
SELECT sections.sequence, sections.term_collection_id, sections.subject_code, sections.course_number, sections.school_id, sections.max_enrollment, sections.instruction_method, sections.campus, sections.enrollment, sections.primary_professor_id, sections.other, section_meetings.meeting_times
FROM section_meetings
JOIN sections ON sections."sequence"           = section_meetings."sequence"
              AND sections.term_collection_id  = section_meetings.term_collection_id
              AND sections.subject_code        = section_meetings.subject_code
              AND sections.course_number       = section_meetings.course_number
              AND sections.school_id           = section_meetings.school_id
WHERE sections.school_id = $1
      AND sections.term_collection_id = $2
ORDER BY sections."sequence", sections.subject_code, sections.course_number, 
    sections.school_id, sections.term_collection_id
LIMIT $4
OFFSET $3
`

type GetSchoolsClassesForTermOrderedBySectionParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
	Offsetvalue      int32  `json:"offsetvalue"`
	Limitvalue       int32  `json:"limitvalue"`
}

type GetSchoolsClassesForTermOrderedBySectionRow struct {
	Section      Section              `json:"section"`
	MeetingTimes []PartialMeetingTime `json:"meeting_times"`
}

func (q *Queries) GetSchoolsClassesForTermOrderedBySection(ctx context.Context, arg GetSchoolsClassesForTermOrderedBySectionParams) ([]GetSchoolsClassesForTermOrderedBySectionRow, error) {
	rows, err := q.db.Query(ctx, getSchoolsClassesForTermOrderedBySection,
		arg.SchoolID,
		arg.TermCollectionID,
		arg.Offsetvalue,
		arg.Limitvalue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchoolsClassesForTermOrderedBySectionRow
	for rows.Next() {
		var i GetSchoolsClassesForTermOrderedBySectionRow
		if err := rows.Scan(
			&i.Section.Sequence,
			&i.Section.TermCollectionID,
			&i.Section.SubjectCode,
			&i.Section.CourseNumber,
			&i.Section.SchoolID,
			&i.Section.MaxEnrollment,
			&i.Section.InstructionMethod,
			&i.Section.Campus,
			&i.Section.Enrollment,
			&i.Section.PrimaryProfessorID,
			&i.Section.Other,
			&i.MeetingTimes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermCollectionsForSchool = `-- name: GetTermCollectionsForSchool :many
SELECT term_collections.id, term_collections.school_id, term_collections.year, term_collections.season, term_collections.name, term_collections.still_collecting
FROM term_collections 
WHERE school_id = $1
LIMIT $3
OFFSET $2
`

type GetTermCollectionsForSchoolParams struct {
	SchoolID    string `json:"school_id"`
	Offsetvalue int32  `json:"offsetvalue"`
	Limitvalue  int32  `json:"limitvalue"`
}

func (q *Queries) GetTermCollectionsForSchool(ctx context.Context, arg GetTermCollectionsForSchoolParams) ([]TermCollection, error) {
	rows, err := q.db.Query(ctx, getTermCollectionsForSchool, arg.SchoolID, arg.Offsetvalue, arg.Limitvalue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TermCollection
	for rows.Next() {
		var i TermCollection
		if err := rows.Scan(
			&i.ID,
			&i.SchoolID,
			&i.Year,
			&i.Season,
			&i.Name,
			&i.StillCollecting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTermCollectionsForSchoolsSemester = `-- name: GetTermCollectionsForSchoolsSemester :many
SELECT term_collections.id, term_collections.school_id, term_collections.year, term_collections.season, term_collections.name, term_collections.still_collecting 
FROM term_collections 
WHERE school_id = $1
      AND (year = $2 OR $2 IS NULL )
      AND (season = $3 OR $3 IS NULL)
`

type GetTermCollectionsForSchoolsSemesterParams struct {
	SchoolID string     `json:"school_id"`
	Year     int32      `json:"year"`
	Season   SeasonEnum `json:"season"`
}

type GetTermCollectionsForSchoolsSemesterRow struct {
	TermCollection TermCollection `json:"term_collection"`
}

func (q *Queries) GetTermCollectionsForSchoolsSemester(ctx context.Context, arg GetTermCollectionsForSchoolsSemesterParams) ([]GetTermCollectionsForSchoolsSemesterRow, error) {
	rows, err := q.db.Query(ctx, getTermCollectionsForSchoolsSemester, arg.SchoolID, arg.Year, arg.Season)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTermCollectionsForSchoolsSemesterRow
	for rows.Next() {
		var i GetTermCollectionsForSchoolsSemesterRow
		if err := rows.Scan(
			&i.TermCollection.ID,
			&i.TermCollection.SchoolID,
			&i.TermCollection.Year,
			&i.TermCollection.Season,
			&i.TermCollection.Name,
			&i.TermCollection.StillCollecting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schoolExists = `-- name: SchoolExists :one
SELECT CASE 
        WHEN EXISTS (
            SELECT 1
            FROM schools
            WHERE id = $1
        ) THEN true
    ELSE false
END
`

func (q *Queries) SchoolExists(ctx context.Context, schoolID string) (bool, error) {
	row := q.db.QueryRow(ctx, schoolExists, schoolID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const termCollectionExists = `-- name: TermCollectionExists :one
SELECT CASE 
        WHEN EXISTS (
            SELECT 1
            FROM term_collections
            WHERE school_id = $1
            AND id = $2
        ) THEN true
    ELSE false
END
`

type TermCollectionExistsParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
}

func (q *Queries) TermCollectionExists(ctx context.Context, arg TermCollectionExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, termCollectionExists, arg.SchoolID, arg.TermCollectionID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
