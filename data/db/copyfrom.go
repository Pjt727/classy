// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: copyfrom.go

package db

import (
	"context"
)

// iteratorForStageCourses implements pgx.CopyFromSource.
type iteratorForStageCourses struct {
	rows                 []StageCoursesParams
	skippedFirstNextCall bool
}

func (r *iteratorForStageCourses) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForStageCourses) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].TermCollectionHistoryID,
		r.rows[0].SchoolID,
		r.rows[0].SubjectCode,
		r.rows[0].Number,
		r.rows[0].SubjectDescription,
		r.rows[0].Title,
		r.rows[0].Description,
		r.rows[0].CreditHours,
		r.rows[0].Other,
	}, nil
}

func (r iteratorForStageCourses) Err() error {
	return nil
}

func (q *Queries) StageCourses(ctx context.Context, arg []StageCoursesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"staging_courses"}, []string{"term_collection_history_id", "school_id", "subject_code", "number", "subject_description", "title", "description", "credit_hours", "other"}, &iteratorForStageCourses{rows: arg})
}

// iteratorForStageMeetingTimes implements pgx.CopyFromSource.
type iteratorForStageMeetingTimes struct {
	rows                 []StageMeetingTimesParams
	skippedFirstNextCall bool
}

func (r *iteratorForStageMeetingTimes) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForStageMeetingTimes) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].TermCollectionHistoryID,
		r.rows[0].Sequence,
		r.rows[0].SectionSequence,
		r.rows[0].TermCollectionID,
		r.rows[0].SubjectCode,
		r.rows[0].CourseNumber,
		r.rows[0].SchoolID,
		r.rows[0].StartDate,
		r.rows[0].EndDate,
		r.rows[0].MeetingType,
		r.rows[0].StartMinutes,
		r.rows[0].EndMinutes,
		r.rows[0].IsMonday,
		r.rows[0].IsTuesday,
		r.rows[0].IsWednesday,
		r.rows[0].IsThursday,
		r.rows[0].IsFriday,
		r.rows[0].IsSaturday,
		r.rows[0].IsSunday,
		r.rows[0].Other,
	}, nil
}

func (r iteratorForStageMeetingTimes) Err() error {
	return nil
}

func (q *Queries) StageMeetingTimes(ctx context.Context, arg []StageMeetingTimesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"staging_meeting_times"}, []string{"term_collection_history_id", "sequence", "section_sequence", "term_collection_id", "subject_code", "course_number", "school_id", "start_date", "end_date", "meeting_type", "start_minutes", "end_minutes", "is_monday", "is_tuesday", "is_wednesday", "is_thursday", "is_friday", "is_saturday", "is_sunday", "other"}, &iteratorForStageMeetingTimes{rows: arg})
}

// iteratorForStageProfessors implements pgx.CopyFromSource.
type iteratorForStageProfessors struct {
	rows                 []StageProfessorsParams
	skippedFirstNextCall bool
}

func (r *iteratorForStageProfessors) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForStageProfessors) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].TermCollectionHistoryID,
		r.rows[0].ID,
		r.rows[0].SchoolID,
		r.rows[0].Name,
		r.rows[0].EmailAddress,
		r.rows[0].FirstName,
		r.rows[0].LastName,
		r.rows[0].Other,
	}, nil
}

func (r iteratorForStageProfessors) Err() error {
	return nil
}

func (q *Queries) StageProfessors(ctx context.Context, arg []StageProfessorsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"staging_professors"}, []string{"term_collection_history_id", "id", "school_id", "name", "email_address", "first_name", "last_name", "other"}, &iteratorForStageProfessors{rows: arg})
}

// iteratorForStageSections implements pgx.CopyFromSource.
type iteratorForStageSections struct {
	rows                 []StageSectionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForStageSections) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForStageSections) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].TermCollectionHistoryID,
		r.rows[0].Sequence,
		r.rows[0].Campus,
		r.rows[0].SubjectCode,
		r.rows[0].CourseNumber,
		r.rows[0].SchoolID,
		r.rows[0].TermCollectionID,
		r.rows[0].Enrollment,
		r.rows[0].MaxEnrollment,
		r.rows[0].InstructionMethod,
		r.rows[0].PrimaryProfessorID,
		r.rows[0].Other,
	}, nil
}

func (r iteratorForStageSections) Err() error {
	return nil
}

func (q *Queries) StageSections(ctx context.Context, arg []StageSectionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"staging_sections"}, []string{"term_collection_history_id", "sequence", "campus", "subject_code", "course_number", "school_id", "term_collection_id", "enrollment", "max_enrollment", "instruction_method", "primary_professor_id", "other"}, &iteratorForStageSections{rows: arg})
}
