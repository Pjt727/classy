// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: entry.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteStagingMeetingTimes = `-- name: DeleteStagingMeetingTimes :exec
DELETE FROM staging_meeting_times
WHERE school_id = $1
     AND term_collection_id = $2
`

type DeleteStagingMeetingTimesParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
}

func (q *Queries) DeleteStagingMeetingTimes(ctx context.Context, arg DeleteStagingMeetingTimesParams) error {
	_, err := q.db.Exec(ctx, deleteStagingMeetingTimes, arg.SchoolID, arg.TermCollectionID)
	return err
}

const deleteStagingSections = `-- name: DeleteStagingSections :exec
DELETE FROM staging_sections
WHERE school_id = $1
    AND term_collection_id = $2
`

type DeleteStagingSectionsParams struct {
	SchoolID         string `json:"school_id"`
	TermCollectionID string `json:"term_collection_id"`
}

func (q *Queries) DeleteStagingSections(ctx context.Context, arg DeleteStagingSectionsParams) error {
	_, err := q.db.Exec(ctx, deleteStagingSections, arg.SchoolID, arg.TermCollectionID)
	return err
}

const finishTermCollectionHistory = `-- name: FinishTermCollectionHistory :exec
UPDATE term_collection_history SET
    status = $1,
    end_time = now()
WHERE id = $2
`

type FinishTermCollectionHistoryParams struct {
	NewFinishedStatus       TermCollectionStatusEnum `json:"new_finished_status"`
	TermCollectionHistoryID int32                    `json:"term_collection_history_id"`
}

func (q *Queries) FinishTermCollectionHistory(ctx context.Context, arg FinishTermCollectionHistoryParams) error {
	_, err := q.db.Exec(ctx, finishTermCollectionHistory, arg.NewFinishedStatus, arg.TermCollectionHistoryID)
	return err
}

const getChangesFromMoveTermCollection = `-- name: GetChangesFromMoveTermCollection :one
SELECT
    t.id,
    SUM(CASE WHEN sync_action = 'insert' THEN 1 ELSE 0 END) AS insert_records,
    SUM(CASE WHEN sync_action = 'update' THEN 1 ELSE 0 END) AS updated_records,
    SUM(CASE WHEN sync_action = 'delete' THEN 1 ELSE 0 END) AS deleted_records,
    (end_time - start_time)::INTERVAL AS elapsed_time
FROM term_collection_history t 
LEFT JOIN historic_class_information h ON t.id = h.term_collection_history_id
WHERE t.id = $1::INTEGER
GROUP BY (t.id, t.end_time, t.start_time)
`

type GetChangesFromMoveTermCollectionRow struct {
	ID             int32           `json:"id"`
	InsertRecords  int64           `json:"insert_records"`
	UpdatedRecords int64           `json:"updated_records"`
	DeletedRecords int64           `json:"deleted_records"`
	ElapsedTime    pgtype.Interval `json:"elapsed_time"`
}

func (q *Queries) GetChangesFromMoveTermCollection(ctx context.Context, termCollectionHistoryID int32) (GetChangesFromMoveTermCollectionRow, error) {
	row := q.db.QueryRow(ctx, getChangesFromMoveTermCollection, termCollectionHistoryID)
	var i GetChangesFromMoveTermCollectionRow
	err := row.Scan(
		&i.ID,
		&i.InsertRecords,
		&i.UpdatedRecords,
		&i.DeletedRecords,
		&i.ElapsedTime,
	)
	return i, err
}

const insertTermCollectionHistory = `-- name: InsertTermCollectionHistory :one
INSERT INTO term_collection_history
    (term_collection_id, school_id, is_full)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertTermCollectionHistoryParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
	IsFull           bool   `json:"is_full"`
}

func (q *Queries) InsertTermCollectionHistory(ctx context.Context, arg InsertTermCollectionHistoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTermCollectionHistory, arg.TermCollectionID, arg.SchoolID, arg.IsFull)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const moveStagedMeetingTimes = `-- name: MoveStagedMeetingTimes :exec
INSERT INTO meeting_times
    (sequence, section_sequence, subject_code,
        term_collection_id, course_number, school_id, 
        start_date, end_date, meeting_type,
        start_minutes, end_minutes, is_monday,
        is_tuesday, is_wednesday, is_thursday,
        is_friday, is_saturday, is_sunday)
SELECT 
    DISTINCT ON (sequence, section_sequence, term_collection_id, subject_code, course_number, school_id)
    sequence, section_sequence, subject_code, 
    term_collection_id, course_number, school_id, 
    start_date, end_date, meeting_type,
    start_minutes, end_minutes, is_monday,
    is_tuesday, is_wednesday, is_thursday,
    is_friday, is_saturday, is_sunday
FROM staging_meeting_times
ON CONFLICT ("sequence", section_sequence, subject_code, course_number, school_id, term_collection_id) DO UPDATE
SET 
    start_date = EXCLUDED.start_date,
    end_date = EXCLUDED.end_date,
    meeting_type = EXCLUDED.meeting_type,
    start_minutes = EXCLUDED.start_minutes,
    end_minutes = EXCLUDED.end_minutes,
    is_monday = EXCLUDED.is_monday,
    is_tuesday = EXCLUDED.is_tuesday,
    is_wednesday = EXCLUDED.is_wednesday,
    is_thursday = EXCLUDED.is_thursday,
    is_friday = EXCLUDED.is_friday,
    is_saturday = EXCLUDED.is_saturday,
    is_sunday = EXCLUDED.is_sunday
WHERE meeting_times.start_date != EXCLUDED.start_date
    OR meeting_times.end_date != EXCLUDED.end_date
    OR meeting_times.meeting_type != EXCLUDED.meeting_type
    OR meeting_times.start_minutes != EXCLUDED.start_minutes
    OR meeting_times.end_minutes != EXCLUDED.end_minutes
    OR meeting_times.is_monday != EXCLUDED.is_monday
    OR meeting_times.is_tuesday != EXCLUDED.is_tuesday
    OR meeting_times.is_wednesday != EXCLUDED.is_wednesday
    OR meeting_times.is_thursday != EXCLUDED.is_thursday
    OR meeting_times.is_friday != EXCLUDED.is_friday
    OR meeting_times.is_saturday != EXCLUDED.is_saturday
    OR meeting_times.is_sunday != EXCLUDED.is_sunday
`

// reducing write locks makes this way faster AND for triggers
func (q *Queries) MoveStagedMeetingTimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, moveStagedMeetingTimes)
	return err
}

const moveStagedSections = `-- name: MoveStagedSections :exec
INSERT INTO sections 
    (sequence, term_collection_id, subject_code,
        course_number, school_id, max_enrollment, 
        instruction_method, campus, enrollment,
        primary_professor_id)
SELECT
    DISTINCT ON (sequence, term_collection_id, subject_code, course_number, school_id)
    sequence, term_collection_id, subject_code,
    course_number, school_id, max_enrollment, 
    instruction_method, campus, enrollment,
    primary_professor_id
FROM staging_sections
ON CONFLICT ("sequence", subject_code, course_number, school_id, term_collection_id) DO UPDATE
SET 
    campus = EXCLUDED.campus,
    enrollment = EXCLUDED.enrollment,
    max_enrollment = EXCLUDED.max_enrollment,
    instruction_method = EXCLUDED.instruction_method,
    primary_professor_id = EXCLUDED.primary_professor_id
WHERE sections.campus != EXCLUDED.campus
    OR sections.enrollment != EXCLUDED.enrollment
    OR sections.max_enrollment != EXCLUDED.max_enrollment
    OR sections.instruction_method != EXCLUDED.instruction_method
    OR sections.primary_professor_id != EXCLUDED.primary_professor_id
`

// reducing write locks makes this way faster ALSO simplfies trigger logic
func (q *Queries) MoveStagedSections(ctx context.Context) error {
	_, err := q.db.Exec(ctx, moveStagedSections)
	return err
}

const removeUnstagedMeetings = `-- name: RemoveUnstagedMeetings :exec
DELETE FROM meeting_times mt
WHERE mt.term_collection_id = $1
  AND mt.school_id = $2
  AND NOT EXISTS (
    SELECT 1 
    FROM staging_meeting_times smt
    WHERE smt."sequence" = mt."sequence"
      AND smt.term_collection_id = mt.term_collection_id
      AND smt.subject_code = mt.subject_code
      AND smt.course_number = mt.course_number
      AND smt.school_id = mt.school_id
      AND smt.section_sequence = mt.section_sequence
  )
`

type RemoveUnstagedMeetingsParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
}

func (q *Queries) RemoveUnstagedMeetings(ctx context.Context, arg RemoveUnstagedMeetingsParams) error {
	_, err := q.db.Exec(ctx, removeUnstagedMeetings, arg.TermCollectionID, arg.SchoolID)
	return err
}

const removeUnstagedSections = `-- name: RemoveUnstagedSections :exec
DELETE FROM sections s
WHERE s.term_collection_id = $1
  AND s.school_id = $2
  AND NOT EXISTS (
    SELECT 1 
    FROM staging_sections ss
    WHERE ss.sequence = s.sequence
      AND ss.term_collection_id = s.term_collection_id
      AND ss.subject_code = s.subject_code
      AND ss.course_number = s.course_number
      AND ss.school_id = s.school_id
  )
`

type RemoveUnstagedSectionsParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
}

func (q *Queries) RemoveUnstagedSections(ctx context.Context, arg RemoveUnstagedSectionsParams) error {
	_, err := q.db.Exec(ctx, removeUnstagedSections, arg.TermCollectionID, arg.SchoolID)
	return err
}

type StageMeetingTimesParams struct {
	Sequence         int32            `json:"sequence"`
	SectionSequence  string           `json:"section_sequence"`
	TermCollectionID string           `json:"term_collection_id"`
	SubjectCode      string           `json:"subject_code"`
	CourseNumber     string           `json:"course_number"`
	SchoolID         string           `json:"school_id"`
	StartDate        pgtype.Timestamp `json:"start_date"`
	EndDate          pgtype.Timestamp `json:"end_date"`
	MeetingType      pgtype.Text      `json:"meeting_type"`
	StartMinutes     pgtype.Time      `json:"start_minutes"`
	EndMinutes       pgtype.Time      `json:"end_minutes"`
	IsMonday         bool             `json:"is_monday"`
	IsTuesday        bool             `json:"is_tuesday"`
	IsWednesday      bool             `json:"is_wednesday"`
	IsThursday       bool             `json:"is_thursday"`
	IsFriday         bool             `json:"is_friday"`
	IsSaturday       bool             `json:"is_saturday"`
	IsSunday         bool             `json:"is_sunday"`
}

type StageSectionsParams struct {
	Sequence           string      `json:"sequence"`
	Campus             pgtype.Text `json:"campus"`
	SubjectCode        string      `json:"subject_code"`
	CourseNumber       string      `json:"course_number"`
	SchoolID           string      `json:"school_id"`
	TermCollectionID   string      `json:"term_collection_id"`
	Enrollment         pgtype.Int4 `json:"enrollment"`
	MaxEnrollment      pgtype.Int4 `json:"max_enrollment"`
	InstructionMethod  pgtype.Text `json:"instruction_method"`
	PrimaryProfessorID pgtype.Text `json:"primary_professor_id"`
}

const upsertSchool = `-- name: UpsertSchool :exec
INSERT INTO schools
    (id, name)
VALUES
    ($1, $2)
ON CONFLICT DO NOTHING
`

type UpsertSchoolParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpsertSchool(ctx context.Context, arg UpsertSchoolParams) error {
	_, err := q.db.Exec(ctx, upsertSchool, arg.ID, arg.Name)
	return err
}
