// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: entry.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteStagingCourses = `-- name: DeleteStagingCourses :exec
DELETE FROM staging_courses
WHERE term_collection_history_id = $1
`

func (q *Queries) DeleteStagingCourses(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, deleteStagingCourses, termCollectionHistoryID)
	return err
}

const deleteStagingMeetingTimes = `-- name: DeleteStagingMeetingTimes :exec
DELETE FROM staging_meeting_times
WHERE term_collection_history_id = $1
`

func (q *Queries) DeleteStagingMeetingTimes(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, deleteStagingMeetingTimes, termCollectionHistoryID)
	return err
}

const deleteStagingProfessors = `-- name: DeleteStagingProfessors :exec
DELETE FROM staging_professors
WHERE term_collection_history_id = $1
`

func (q *Queries) DeleteStagingProfessors(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, deleteStagingProfessors, termCollectionHistoryID)
	return err
}

const deleteStagingSections = `-- name: DeleteStagingSections :exec
DELETE FROM staging_sections
WHERE term_collection_history_id = $1
`

func (q *Queries) DeleteStagingSections(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, deleteStagingSections, termCollectionHistoryID)
	return err
}

const finishTermCollectionHistory = `-- name: FinishTermCollectionHistory :exec
UPDATE term_collection_history SET
    status = $1,
    end_time = now()
WHERE id = $2
`

type FinishTermCollectionHistoryParams struct {
	NewFinishedStatus       TermCollectionStatusEnum `json:"new_finished_status"`
	TermCollectionHistoryID int32                    `json:"term_collection_history_id"`
}

func (q *Queries) FinishTermCollectionHistory(ctx context.Context, arg FinishTermCollectionHistoryParams) error {
	_, err := q.db.Exec(ctx, finishTermCollectionHistory, arg.NewFinishedStatus, arg.TermCollectionHistoryID)
	return err
}

const getChangesFromMoveTermCollection = `-- name: GetChangesFromMoveTermCollection :one
SELECT
    t.id,
    SUM(CASE WHEN sync_action = 'insert' THEN 1 ELSE 0 END) AS insert_records,
    SUM(CASE WHEN sync_action = 'update' THEN 1 ELSE 0 END) AS updated_records,
    SUM(CASE WHEN sync_action = 'delete' THEN 1 ELSE 0 END) AS deleted_records,
    (end_time - start_time)::INTERVAL AS elapsed_time
FROM term_collection_history t 
LEFT JOIN historic_class_information h ON t.id = h.term_collection_history_id
WHERE t.id = $1::INTEGER
GROUP BY (t.id, t.end_time, t.start_time)
`

type GetChangesFromMoveTermCollectionRow struct {
	ID             int32           `json:"id"`
	InsertRecords  int64           `json:"insert_records"`
	UpdatedRecords int64           `json:"updated_records"`
	DeletedRecords int64           `json:"deleted_records"`
	ElapsedTime    pgtype.Interval `json:"elapsed_time"`
}

func (q *Queries) GetChangesFromMoveTermCollection(ctx context.Context, termCollectionHistoryID int32) (GetChangesFromMoveTermCollectionRow, error) {
	row := q.db.QueryRow(ctx, getChangesFromMoveTermCollection, termCollectionHistoryID)
	var i GetChangesFromMoveTermCollectionRow
	err := row.Scan(
		&i.ID,
		&i.InsertRecords,
		&i.UpdatedRecords,
		&i.DeletedRecords,
		&i.ElapsedTime,
	)
	return i, err
}

const insertTermCollectionHistory = `-- name: InsertTermCollectionHistory :one
INSERT INTO term_collection_history
    (term_collection_id, school_id, is_full)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertTermCollectionHistoryParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
	IsFull           bool   `json:"is_full"`
}

func (q *Queries) InsertTermCollectionHistory(ctx context.Context, arg InsertTermCollectionHistoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTermCollectionHistory, arg.TermCollectionID, arg.SchoolID, arg.IsFull)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const moveCourses = `-- name: MoveCourses :exec
INSERT INTO courses 
    (school_id, subject_code, number, subject_description, title,
        description, credit_hours, prerequisites, corequisites, other)
SELECT DISTINCT ON (school_id, subject_code, number) 
    school_id, subject_code, number, subject_description, title, 
    description, credit_hours, prerequisites, corequisites, other
FROM staging_courses WHERE term_collection_history_id = $1
ON CONFLICT (school_id, subject_code, number) DO UPDATE
SET subject_description = COALESCE(EXCLUDED.subject_description, courses.subject_description),
    title = COALESCE(EXCLUDED.title, courses.title),
    credit_hours = COALESCE(EXCLUDED.credit_hours, courses.credit_hours),
    description = COALESCE(EXCLUDED.description, courses.description),
    prerequisites = COALESCE(EXCLUDED.prerequisites, courses.prerequisites),
    corequisites = COALESCE(EXCLUDED.corequisites, courses.corequisites),
    other = COALESCE(EXCLUDED.other, courses.other)
  WHERE (courses.title IS DISTINCT FROM EXCLUDED.title AND EXCLUDED.title IS NOT NULL)
      OR (courses.credit_hours IS DISTINCT FROM EXCLUDED.credit_hours AND EXCLUDED.credit_hours IS NOT NULL)
      OR (courses.subject_description IS DISTINCT FROM EXCLUDED.subject_description AND EXCLUDED.subject_description IS NOT NULL)
      -- these are considered "extra" fields that may no always be populated
      --     because they are difficult to get
      OR (courses.prerequisites IS DISTINCT FROM EXCLUDED.prerequisites AND EXCLUDED.prerequisites IS NOT NULL)
      OR (courses.corequisites IS DISTINCT FROM EXCLUDED.corequisites AND EXCLUDED.corequisites IS NOT NULL)
      OR (courses.description IS DISTINCT FROM EXCLUDED.description AND EXCLUDED.description IS NOT NULL)
      OR (courses.other IS DISTINCT FROM EXCLUDED.other AND EXCLUDED.other IS NOT NULL)
`

func (q *Queries) MoveCourses(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, moveCourses, termCollectionHistoryID)
	return err
}

const moveProfessors = `-- name: MoveProfessors :exec
INSERT INTO professors (id, school_id, name, email_address, first_name, last_name, other)
SELECT DISTINCT ON (id, school_id) id, school_id, name, email_address, first_name, last_name, other
FROM staging_professors WHERE term_collection_history_id = $1
ON CONFLICT (id, school_id) DO UPDATE
SET name = COALESCE(EXCLUDED.name, professors.name),
    email_address = COALESCE(EXCLUDED.email_address, professors.email_address),
    first_name = COALESCE(EXCLUDED.first_name, professors.first_name),
    last_name = COALESCE(EXCLUDED.last_name, professors.last_name),
    other = COALESCE(EXCLUDED.other, professors.other)
  WHERE (professors.name IS DISTINCT FROM EXCLUDED.name AND EXCLUDED.name IS NOT NULL)
      OR (professors.email_address IS DISTINCT FROM EXCLUDED.email_address AND EXCLUDED.email_address IS NOT NULL)
      OR (professors.first_name IS DISTINCT FROM EXCLUDED.first_name AND EXCLUDED.first_name IS NOT NULL)
      OR (professors.last_name IS DISTINCT FROM EXCLUDED.last_name AND EXCLUDED.last_name IS NOT NULL)
      OR (professors.other IS DISTINCT FROM EXCLUDED.other AND EXCLUDED.other IS NOT NULL)
`

func (q *Queries) MoveProfessors(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, moveProfessors, termCollectionHistoryID)
	return err
}

const moveStagedMeetingTimes = `-- name: MoveStagedMeetingTimes :exec
INSERT INTO meeting_times
    (sequence, section_sequence, subject_code,
        term_collection_id, course_number, school_id, 
        start_date, end_date, meeting_type,
        start_minutes, end_minutes, is_monday,
        is_tuesday, is_wednesday, is_thursday,
        is_friday, is_saturday, is_sunday, other)
SELECT 
    DISTINCT ON (sequence, section_sequence, term_collection_id, subject_code, course_number, school_id)
    sequence, section_sequence, subject_code, 
    term_collection_id, course_number, school_id, 
    start_date, end_date, meeting_type,
    start_minutes, end_minutes, is_monday,
    is_tuesday, is_wednesday, is_thursday,
    is_friday, is_saturday, is_sunday, other
FROM staging_meeting_times WHERE term_collection_history_id = $1
ON CONFLICT ("sequence", section_sequence, subject_code, course_number, school_id, term_collection_id) DO UPDATE
SET 
    start_date = COALESCE(EXCLUDED.start_date, meeting_times.start_date),
    end_date = COALESCE(EXCLUDED.end_date, meeting_times.end_date),
    meeting_type = COALESCE(EXCLUDED.meeting_type, meeting_times.meeting_type),
    start_minutes = COALESCE(EXCLUDED.start_minutes, meeting_times.start_minutes),
    end_minutes = COALESCE(EXCLUDED.end_minutes, meeting_times.end_minutes),
    is_monday = EXCLUDED.is_monday,
    is_tuesday = EXCLUDED.is_tuesday,
    is_wednesday = EXCLUDED.is_wednesday,
    is_thursday = EXCLUDED.is_thursday,
    is_friday = EXCLUDED.is_friday,
    is_saturday = EXCLUDED.is_saturday,
    is_sunday = EXCLUDED.is_sunday,
    other = COALESCE(EXCLUDED.other, meeting_times.other)
  -- reducing write locks makes this way faster AND for triggers
  WHERE (meeting_times.start_date IS DISTINCT FROM EXCLUDED.start_date AND EXCLUDED.start_date IS NOT NULL)
      OR (meeting_times.end_date IS DISTINCT FROM EXCLUDED.end_date AND EXCLUDED.end_date IS NOT NULL)
      OR (meeting_times.meeting_type IS DISTINCT FROM EXCLUDED.meeting_type AND EXCLUDED.meeting_type IS NOT NULL)
      OR (meeting_times.start_minutes IS DISTINCT FROM EXCLUDED.start_minutes AND EXCLUDED.start_minutes IS NOT NULL)
      OR (meeting_times.end_minutes IS DISTINCT FROM EXCLUDED.end_minutes AND EXCLUDED.end_minutes IS NOT NULL)
      OR meeting_times.is_monday IS DISTINCT FROM EXCLUDED.is_monday
      OR meeting_times.is_tuesday IS DISTINCT FROM EXCLUDED.is_tuesday
      OR meeting_times.is_wednesday IS DISTINCT FROM EXCLUDED.is_wednesday
      OR meeting_times.is_thursday IS DISTINCT FROM EXCLUDED.is_thursday
      OR meeting_times.is_friday IS DISTINCT FROM EXCLUDED.is_friday
      OR meeting_times.is_saturday IS DISTINCT FROM EXCLUDED.is_saturday
      OR meeting_times.is_sunday IS DISTINCT FROM EXCLUDED.is_sunday
      OR (meeting_times.other IS DISTINCT FROM EXCLUDED.other AND EXCLUDED.other IS NOT NULL)
`

func (q *Queries) MoveStagedMeetingTimes(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, moveStagedMeetingTimes, termCollectionHistoryID)
	return err
}

const moveStagedSections = `-- name: MoveStagedSections :exec
INSERT INTO sections 
    (sequence, term_collection_id, subject_code,
        course_number, school_id, max_enrollment, 
        instruction_method, campus, enrollment,
        primary_professor_id, other)
SELECT
    DISTINCT ON (sequence, term_collection_id, subject_code, course_number, school_id)
    sequence, term_collection_id, subject_code,
    course_number, school_id, max_enrollment, 
    instruction_method, campus, enrollment,
    primary_professor_id, other
FROM staging_sections WHERE term_collection_history_id = $1
ON CONFLICT ("sequence", subject_code, course_number, school_id, term_collection_id) DO UPDATE
SET 
    campus = EXCLUDED.campus,
    enrollment = EXCLUDED.enrollment,
    max_enrollment = EXCLUDED.max_enrollment,
    instruction_method = EXCLUDED.instruction_method,
    primary_professor_id = EXCLUDED.primary_professor_id,
    other = EXCLUDED.other
  -- reducing write locks makes this way faster ALSO simplfies trigger logic
  WHERE sections.campus IS DISTINCT FROM EXCLUDED.campus
      OR sections.enrollment IS DISTINCT FROM EXCLUDED.enrollment
      OR sections.max_enrollment IS DISTINCT FROM EXCLUDED.max_enrollment
      OR sections.instruction_method IS DISTINCT FROM EXCLUDED.instruction_method
      OR sections.primary_professor_id IS DISTINCT FROM EXCLUDED.primary_professor_id
      OR sections.other IS DISTINCT FROM EXCLUDED.other
`

func (q *Queries) MoveStagedSections(ctx context.Context, termCollectionHistoryID int32) error {
	_, err := q.db.Exec(ctx, moveStagedSections, termCollectionHistoryID)
	return err
}

const removeUnstagedMeetings = `-- name: RemoveUnstagedMeetings :exec
DELETE FROM meeting_times mt
WHERE mt.term_collection_id = $1
  AND mt.school_id = $2
  AND NOT EXISTS (
    SELECT 1 
    FROM staging_meeting_times smt
    WHERE smt."sequence" = mt."sequence"
      AND smt.term_collection_id = mt.term_collection_id
      AND smt.subject_code = mt.subject_code
      AND smt.course_number = mt.course_number
      AND smt.school_id = mt.school_id
      AND smt.section_sequence = mt.section_sequence
  )
`

type RemoveUnstagedMeetingsParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
}

func (q *Queries) RemoveUnstagedMeetings(ctx context.Context, arg RemoveUnstagedMeetingsParams) error {
	_, err := q.db.Exec(ctx, removeUnstagedMeetings, arg.TermCollectionID, arg.SchoolID)
	return err
}

const removeUnstagedSections = `-- name: RemoveUnstagedSections :exec
DELETE FROM sections s
WHERE s.term_collection_id = $1
  AND s.school_id = $2
  AND NOT EXISTS (
    SELECT 1 
    FROM staging_sections ss
    WHERE ss.sequence = s.sequence
      AND ss.term_collection_id = s.term_collection_id
      AND ss.subject_code = s.subject_code
      AND ss.course_number = s.course_number
      AND ss.school_id = s.school_id
  )
`

type RemoveUnstagedSectionsParams struct {
	TermCollectionID string `json:"term_collection_id"`
	SchoolID         string `json:"school_id"`
}

func (q *Queries) RemoveUnstagedSections(ctx context.Context, arg RemoveUnstagedSectionsParams) error {
	_, err := q.db.Exec(ctx, removeUnstagedSections, arg.TermCollectionID, arg.SchoolID)
	return err
}

type StageCoursesParams struct {
	TermCollectionHistoryID int32       `json:"term_collection_history_id"`
	SchoolID                string      `json:"school_id"`
	SubjectCode             string      `json:"subject_code"`
	Number                  string      `json:"number"`
	SubjectDescription      pgtype.Text `json:"subject_description"`
	Title                   pgtype.Text `json:"title"`
	Description             pgtype.Text `json:"description"`
	CreditHours             float32     `json:"credit_hours"`
	Other                   []byte      `json:"other"`
}

type StageMeetingTimesParams struct {
	TermCollectionHistoryID int32            `json:"term_collection_history_id"`
	Sequence                int32            `json:"sequence"`
	SectionSequence         string           `json:"section_sequence"`
	TermCollectionID        string           `json:"term_collection_id"`
	SubjectCode             string           `json:"subject_code"`
	CourseNumber            string           `json:"course_number"`
	SchoolID                string           `json:"school_id"`
	StartDate               pgtype.Timestamp `json:"start_date"`
	EndDate                 pgtype.Timestamp `json:"end_date"`
	MeetingType             pgtype.Text      `json:"meeting_type"`
	StartMinutes            pgtype.Time      `json:"start_minutes"`
	EndMinutes              pgtype.Time      `json:"end_minutes"`
	IsMonday                bool             `json:"is_monday"`
	IsTuesday               bool             `json:"is_tuesday"`
	IsWednesday             bool             `json:"is_wednesday"`
	IsThursday              bool             `json:"is_thursday"`
	IsFriday                bool             `json:"is_friday"`
	IsSaturday              bool             `json:"is_saturday"`
	IsSunday                bool             `json:"is_sunday"`
	Other                   []byte           `json:"other"`
}

type StageProfessorsParams struct {
	TermCollectionHistoryID int32       `json:"term_collection_history_id"`
	ID                      string      `json:"id"`
	SchoolID                string      `json:"school_id"`
	Name                    string      `json:"name"`
	EmailAddress            pgtype.Text `json:"email_address"`
	FirstName               pgtype.Text `json:"first_name"`
	LastName                pgtype.Text `json:"last_name"`
	Other                   []byte      `json:"other"`
}

type StageSectionsParams struct {
	TermCollectionHistoryID int32       `json:"term_collection_history_id"`
	Sequence                string      `json:"sequence"`
	Campus                  pgtype.Text `json:"campus"`
	SubjectCode             string      `json:"subject_code"`
	CourseNumber            string      `json:"course_number"`
	SchoolID                string      `json:"school_id"`
	TermCollectionID        string      `json:"term_collection_id"`
	Enrollment              pgtype.Int4 `json:"enrollment"`
	MaxEnrollment           pgtype.Int4 `json:"max_enrollment"`
	InstructionMethod       pgtype.Text `json:"instruction_method"`
	PrimaryProfessorID      pgtype.Text `json:"primary_professor_id"`
	Other                   []byte      `json:"other"`
}

const upsertSchool = `-- name: UpsertSchool :exec
INSERT INTO schools
    (id, name)
VALUES
    ($1, $2)
ON CONFLICT DO NOTHING
`

type UpsertSchoolParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpsertSchool(ctx context.Context, arg UpsertSchoolParams) error {
	_, err := q.db.Exec(ctx, upsertSchool, arg.ID, arg.Name)
	return err
}
