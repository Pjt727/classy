// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sync.sql

package db

import (
	"context"
)

const syncAll = `-- name: SyncAll :many
SELECT
  sequence,
  table_name,
  pk_fields,
  sync_action,
  relevant_fields,
  COUNT(*) OVER() AS total_rows
FROM
(SELECT
    sequence, table_name, updated_input_at, composite_hash, school_id, pk_fields, sync_action, relevant_fields,
    ROW_NUMBER() OVER (PARTITION BY school_id, table_name, composite_hash ORDER BY sequence ASC) AS rn
    FROM
    sync_diffs s
    WHERE s.sequence > $1
) as RankedData
WHERE
  rn = 1
ORDER BY sequence
LIMIT $2::int
`

type SyncAllParams struct {
	LastSequence int32 `json:"last_sequence"`
	MaxRecords   int32 `json:"max_records"`
}

type SyncAllRow struct {
	Sequence       int32                  `json:"sequence"`
	TableName      string                 `json:"table_name"`
	PkFields       map[string]interface{} `json:"pk_fields"`
	SyncAction     string                 `json:"sync_action"`
	RelevantFields map[string]interface{} `json:"relevant_fields"`
	TotalRows      int64                  `json:"total_rows"`
}

func (q *Queries) SyncAll(ctx context.Context, arg SyncAllParams) ([]SyncAllRow, error) {
	rows, err := q.db.Query(ctx, syncAll, arg.LastSequence, arg.MaxRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncAllRow
	for rows.Next() {
		var i SyncAllRow
		if err := rows.Scan(
			&i.Sequence,
			&i.TableName,
			&i.PkFields,
			&i.SyncAction,
			&i.RelevantFields,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncSchool = `-- name: SyncSchool :many
SELECT
  sequence,
  table_name,
  pk_fields,
  sync_action,
  relevant_fields,
  COUNT(*) OVER() AS total_rows
FROM
(SELECT
    sequence, table_name, updated_input_at, composite_hash, school_id, pk_fields, sync_action, relevant_fields,
    ROW_NUMBER() OVER (PARTITION BY school_id, table_name, composite_hash ORDER BY sequence ASC) AS rn
    FROM
    sync_diffs s
    WHERE s.sequence > $1 
          AND s.school_id = $2
) as RankedData
WHERE
  rn = 1
ORDER BY sequence
LIMIT $3::int
`

type SyncSchoolParams struct {
	LastSequence int32  `json:"last_sequence"`
	SchoolID     string `json:"school_id"`
	MaxRecords   int32  `json:"max_records"`
}

type SyncSchoolRow struct {
	Sequence       int32                  `json:"sequence"`
	TableName      string                 `json:"table_name"`
	PkFields       map[string]interface{} `json:"pk_fields"`
	SyncAction     string                 `json:"sync_action"`
	RelevantFields map[string]interface{} `json:"relevant_fields"`
	TotalRows      int64                  `json:"total_rows"`
}

func (q *Queries) SyncSchool(ctx context.Context, arg SyncSchoolParams) ([]SyncSchoolRow, error) {
	rows, err := q.db.Query(ctx, syncSchool, arg.LastSequence, arg.SchoolID, arg.MaxRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncSchoolRow
	for rows.Next() {
		var i SyncSchoolRow
		if err := rows.Scan(
			&i.Sequence,
			&i.TableName,
			&i.PkFields,
			&i.SyncAction,
			&i.RelevantFields,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncTerm = `-- name: SyncTerm :many
SELECT
  sequence,
  table_name,
  pk_fields,
  sync_action,
  relevant_fields,
  COUNT(*) OVER() AS total_rows
FROM
(SELECT
    sequence, table_name, updated_input_at, composite_hash, school_id, pk_fields, sync_action, relevant_fields,
    ROW_NUMBER() OVER (PARTITION BY school_id, table_name, composite_hash ORDER BY sequence ASC) AS rn
    FROM
    sync_diffs s
    WHERE 
    s.school_id = $1
    AND s.sequence > $2
    AND (
    -- records that are/ were invovled in the term e.i. professors teaching a section in that term
    (s.composite_hash, s.table_name) IN (
            SELECT h.historic_composite_hash, h.table_name
            FROM historic_class_information_term_dependencies h
            WHERE h.term_collection_id = $3 and h.school_id = $1
        )
    -- sections / meeting times that are directly in the term
    OR (s.pk_fields ? 'term_collection_id' AND s.pk_fields ->> 'term_collection_id' = $3)
    -- possible updated data on the school 
    OR table_name = 'schools'
    -- possible updated data on the term collection
    OR (table_name = 'term_collections' AND s.pk_fields ->> 'id' = $3)
    )
) as RankedData
WHERE
  rn = 1
ORDER BY sequence
LIMIT $4::int
`

type SyncTermParams struct {
	SchoolID         string `json:"school_id"`
	LastTermSequence int32  `json:"last_term_sequence"`
	TermCollectionID string `json:"term_collection_id"`
	MaxRecords       int32  `json:"max_records"`
}

type SyncTermRow struct {
	Sequence       int32                  `json:"sequence"`
	TableName      string                 `json:"table_name"`
	PkFields       map[string]interface{} `json:"pk_fields"`
	SyncAction     string                 `json:"sync_action"`
	RelevantFields map[string]interface{} `json:"relevant_fields"`
	TotalRows      int64                  `json:"total_rows"`
}

// gives only the data that is directly related with that term at any point of time
func (q *Queries) SyncTerm(ctx context.Context, arg SyncTermParams) ([]SyncTermRow, error) {
	rows, err := q.db.Query(ctx, syncTerm,
		arg.SchoolID,
		arg.LastTermSequence,
		arg.TermCollectionID,
		arg.MaxRecords,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncTermRow
	for rows.Next() {
		var i SyncTermRow
		if err := rows.Scan(
			&i.Sequence,
			&i.TableName,
			&i.PkFields,
			&i.SyncAction,
			&i.RelevantFields,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
