// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sync.sql

package db

import (
	"context"
)

const getLastSequence = `-- name: GetLastSequence :one
SELECT MAX(sequence)::int FROM historic_class_information
`

func (q *Queries) GetLastSequence(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getLastSequence)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getLastestSyncChanges = `-- name: GetLastestSyncChanges :many
SELECT
  sequence,
  table_name,
  pk_fields,
  sync_action,
  relevant_fields
FROM
(SELECT
    sequence, table_name, updated_input_at, composite_hash, school_id, pk_fields, sync_action, relevant_fields,
    ROW_NUMBER() OVER (PARTITION BY school_id, table_name, composite_hash ORDER BY sequence ASC) AS rn
    FROM
    sync_diffs s
    WHERE sync_diffs.sequence > $1
) as RankedData
WHERE
  rn = 1
`

type GetLastestSyncChangesRow struct {
	Sequence       int32                  `json:"sequence"`
	TableName      string                 `json:"table_name"`
	PkFields       []string               `json:"pk_fields"`
	SyncAction     string                 `json:"sync_action"`
	RelevantFields map[string]interface{} `json:"relevant_fields"`
}

func (q *Queries) GetLastestSyncChanges(ctx context.Context, lastSequence int32) ([]GetLastestSyncChangesRow, error) {
	rows, err := q.db.Query(ctx, getLastestSyncChanges, lastSequence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastestSyncChangesRow
	for rows.Next() {
		var i GetLastestSyncChangesRow
		if err := rows.Scan(
			&i.Sequence,
			&i.TableName,
			&i.PkFields,
			&i.SyncAction,
			&i.RelevantFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastestSyncChangesForTerms = `-- name: GetLastestSyncChangesForTerms :many
SELECT
  sequence,
  table_name,
  pk_fields,
  sync_action,
  relevant_fields
FROM
(SELECT
    sequence, table_name, updated_input_at, composite_hash, school_id, pk_fields, sync_action, relevant_fields,
    ROW_NUMBER() OVER (PARTITION BY school_id, table_name, composite_hash ORDER BY sequence ASC) AS rn
    FROM
    sync_diffs
    WHERE (updated_pk_fields->'term_collection_id' IS NULL AND EXISTS ( -- see if this improves performance
            SELECT 1
            FROM generate_series(1, array_length($1::string[], 1)) AS i
            WHERE school_id = ($2::string[])[i]
            AND table_name = ($1::string[])[i]
            AND sequence > ($3::int[])[i]
            ))
            OR (
                SELECT 1
                FROM generate_series(1, array_length($4::string[], 1)) AS i
                WHERE school_id = ($2::string[])[i]
                AND term_collection_id = ($4::string[])[i]
                AND sequence > ($5::int[])[i]
            )) as RankedData
WHERE
  rn = 1
`

type GetLastestSyncChangesForTermsParams struct {
	CommonTables            []string `json:"common_tables"`
	SchoolID                []string `json:"school_id"`
	CommonSequences         []int32  `json:"common_sequences"`
	TermCollectionID        []string `json:"term_collection_id"`
	TermCollectionSequences []int32  `json:"term_collection_sequences"`
}

type GetLastestSyncChangesForTermsRow struct {
	Sequence       int32                  `json:"sequence"`
	TableName      string                 `json:"table_name"`
	PkFields       []string               `json:"pk_fields"`
	SyncAction     string                 `json:"sync_action"`
	RelevantFields map[string]interface{} `json:"relevant_fields"`
}

// all array inputs must be flattened to be the same length
func (q *Queries) GetLastestSyncChangesForTerms(ctx context.Context, arg GetLastestSyncChangesForTermsParams) ([]GetLastestSyncChangesForTermsRow, error) {
	rows, err := q.db.Query(ctx, getLastestSyncChangesForTerms,
		arg.CommonTables,
		arg.SchoolID,
		arg.CommonSequences,
		arg.TermCollectionID,
		arg.TermCollectionSequences,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastestSyncChangesForTermsRow
	for rows.Next() {
		var i GetLastestSyncChangesForTermsRow
		if err := rows.Scan(
			&i.Sequence,
			&i.TableName,
			&i.PkFields,
			&i.SyncAction,
			&i.RelevantFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
